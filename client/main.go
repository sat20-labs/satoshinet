package main

import (
	"log"
	"os"
	"path/filepath"

	// "github.com/sat20-labs/satoshinet/btcutil"
	"github.com/sat20-labs/satoshinet/btcjson"
	"github.com/sat20-labs/satoshinet/btcutil"
	"github.com/sat20-labs/satoshinet/rpcclient"
	"github.com/sat20-labs/satoshinet/wire"
)

func main() {
	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	// btcdHomeDir := btcutil.AppDataDir("btcd", false)
	// var btcdHomeDir string = "./"
	btcdHomeDir := btcutil.AppDataDir("btcd", false)
	// certPath := "/Users/wenjiechen/Library/Application Support/Btcd/rpc.cert"
	certs, err := os.ReadFile(filepath.Join(btcdHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host: "192.168.10.188:8337",
		User: "jacky",
		Pass: "_RZekaGRgKQJSIOYi6vq0_CkJtjoCootamy81J2cDn0",
		// Endpoint:     "ws",
		Certificates: certs,
		HTTPPostMode: true, // 启用 HTTP POST 模式
		// DisableTLS:   true, // 禁用 TLS
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}

	result0, err := client.GetInfo()
	if err != nil {
		log.Print(err)
	}
	log.Println(result0)

	// no implement in btcd, but will implement soon
	result, err := client.EstimateSmartFee(6, nil)
	if err != nil {
		log.Print(err)
	}
	log.Println(result)

	result1, err := client.EstimateFee(6)
	if err != nil {
		log.Print(err)
	}
	log.Println(result1)

	rawHex := "1a2b3c"
	cmd := btcjson.NewTestMempoolAcceptCmd([]string{rawHex}, 0.1)
	var respChan rpcclient.FutureTestMempoolAcceptResult = client.SendCmd(cmd)
	result2, err := respChan.Receive()
	if err != nil {
		log.Print(err)
	}

	log.Println(result2)

	var txns []*wire.MsgTx
	result3, err := client.TestMempoolAccept(txns, 0.1)
	if err != nil {
		log.Print(err)
	}
	log.Println(result3)

	result4, err := client.GetBlockChainInfo()
	if err != nil {
		log.Print(err)
	}
	log.Println(result4)

	defer client.Shutdown()

	// Query the RPC server for the current block count and display it.
	blockCount, err := client.GetBlockCount()
	if err != nil {
		log.Print(err)
	}
	log.Printf("Block count: %d", blockCount)
}
